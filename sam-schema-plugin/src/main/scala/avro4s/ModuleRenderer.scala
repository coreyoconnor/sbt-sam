package avro4s

class ModuleRenderer {

  def apply(record: RecordType): String = {
    val caseClass: String =
      s"""
        |//auto generated by $BuildInfo
        |object ${record.name} {
        |  import play.api.libs.json._
        |  implicit val format: Format[${record.name}] = Json.format
        |}
        |case class ${record.name}(
        |${record.fields.map(TypeRenderer.render).mkString(",\n")}
        |)
      """.stripMargin

    s"//auto generated by $BuildInfo\ncase class ${record.name}(\n" + record.fields.map(TypeRenderer.render).mkString(",\n") + "\n)"

    val unionFieldTypes = record.fields.collect {
      case FieldDef(name, unionType @ UnionType(types), _) if types.count(_ != NullType) > 2 =>
        s"  type ${name.capitalize}Type = ${TypeRenderer.renderType(unionType)}"
    }

    if (unionFieldTypes.nonEmpty) {
      val companionObject = s"//auto generated by $BuildInfo\nobject ${record.name} {\n" +
        unionFieldTypes.mkString("\n") +
        "\n}"
      caseClass ++ "\n\n" ++ companionObject
    } else {
      caseClass
    }
  }

  def apply(fixed: FixedType): String = {
    s"//auto generated code by $BuildInfo\n@com.sksamuel.avro4s.AvroFixed(${fixed.length})\ncase class ${fixed.name}(bytes: scala.collection.mutable.WrappedArray.ofByte) extends AnyVal"
  }

  def apply(enum: EnumType): String = {
    s"//auto generated code by $BuildInfo\npublic enum ${enum.name}" + enum.symbols.mkString("{\n    ", ", ", "\n}")
  }

  def apply(module: Module): String = {
    module match {
      case r: RecordType => apply(r)
      case e: EnumType   => apply(e)
      case f: FixedType  => apply(f)
    }
  }
}